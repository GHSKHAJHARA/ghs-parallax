
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GHS Khajhara | Premium Parallax</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
    overflow-x: hidden;
    background: #fff;
  }
  body {
    font-family: sans-serif;
    color: #222;
  }
  canvas {
    display: block;
  }
  .page {
    position: relative;
    width: 100%;
  }
  .overlay-title {
    position: fixed;
    left: 20px;
    top: 20px;
    z-index: 50;
    font-weight: 700;
    letter-spacing: 1px;
    background: rgba(255,255,255,0.85);
    padding: 8px 12px;
    border-radius: 8px;
    color: #333;
    border-left: 4px solid gold;
    box-shadow: 0 2px 8px rgba(200,200,200,0.15);
  }
  .no-webgl {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #fff;
    color: #222;
    font-size: 18px;
    text-align: center;
    padding: 20px;
    z-index: 9999;
  }
</style>
</head>
<body>

<div class="overlay-title">Rajkiya High School Khajhara</div>

<div id="pages" class="page"></div>
<div id="webgl-root"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

<script>
// ---------- WebGL Check ----------
if (!window.WebGLRenderingContext) {
  document.body.insertAdjacentHTML('afterbegin', '<div class="no-webgl">WebGL not supported.</div>');
  throw new Error('No WebGL support');
}

// ---------- Configuration ----------
const IMAGE_URLS = [
  "https://raw.githubusercontent.com/GHSKHAJHARA/ghs-parallax/main/GHS.png",
  "https://raw.githubusercontent.com/GHSKHAJHARA/ghs-parallax/main/Science%20exhibition.png",
  "https://raw.githubusercontent.com/GHSKHAJHARA/ghs-parallax/main/exhibition.png",
  "https://raw.githubusercontent.com/GHSKHAJHARA/ghs-parallax/main/poster.png",
  "https://raw.githubusercontent.com/GHSKHAJHARA/ghs-parallax/main/post.png",
  "https://raw.githubusercontent.com/GHSKHAJHARA/ghs-parallax/main/preyer.png",
  "https://raw.githubusercontent.com/GHSKHAJHARA/ghs-parallax/main/preyer.png" // agar duplicate nahi chahiye, ise hata dein
];

const SCENE_COUNT = IMAGE_URLS.length;
const VIEWPORT = { w: window.innerWidth, h: window.innerHeight };
const SCENE_DISTANCE = 2.2;
const CAMERA_Z = 1.6;
const MOUSE_INTENSITY = 0.25;
const LERP_EASE = 0.08;

// ---------- Three.js Setup ----------
const container = document.getElementById('webgl-root');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(VIEWPORT.w, VIEWPORT.h);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);
scene.fog = new THREE.FogExp2(0xffffff, 0.25);

const camera = new THREE.PerspectiveCamera(50, VIEWPORT.w / VIEWPORT.h, 0.1, 100);
camera.position.z = CAMERA_Z;
camera.position.y = 0;

const ambient = new THREE.AmbientLight(0xffffff, 1.0);
scene.add(ambient);
const dir = new THREE.DirectionalLight(0xffffff, 0.2);
dir.position.set(0.5, 1, 0.5);
scene.add(dir);

const loader = new THREE.TextureLoader();
loader.crossOrigin = "anonymous";

const planes = [];
let targetScroll = 0, currentScroll = 0;
let mouse = { x: 0, y: 0 }, mouseLerp = { x: 0, y: 0 };

const pagesEl = document.getElementById('pages');
function buildPageHeight() {
  pagesEl.innerHTML = '';
  for (let i = 0; i < SCENE_COUNT; i++) {
    const el = document.createElement('div');
    el.style.height = window.innerHeight + 'px';
    pagesEl.appendChild(el);
  }
}
buildPageHeight();

function makePlaneMesh(texture) {
  const aspect = texture.image.width / texture.image.height;
  const vFOV = (camera.fov * Math.PI) / 180;
  const visibleHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
  const height = visibleHeight * 1.15;
  const width = height * aspect;
  const geo = new THREE.PlaneGeometry(width, height, 32, 32);
  const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
  return new THREE.Mesh(geo, mat);
}

async function loadTextures(urls) {
  const promises = urls.map(url => new Promise((res, rej) => {
    loader.load(url, tex => res(tex), undefined, err => res(null));
  }));
  return Promise.all(promises);
}

async function init() {
  const textures = await loadTextures(IMAGE_URLS);
  textures.forEach((tex, i) => {
    if (!tex) return;
    const mesh = makePlaneMesh(tex);
    mesh.position.y = -i * SCENE_DISTANCE;
    mesh.position.z = -0.2 * (i % 3);
    const s = 1 + (0.02 * (i % 3));
    mesh.scale.set(s, s, s);
    scene.add(mesh);
    planes.push({ mesh, index: i });
  });
  setupListeners();
  animate();
}

function setupListeners() {
  window.addEventListener('scroll', () => { targetScroll = window.scrollY || window.pageYOffset; }, { passive: true });
  window.addEventListener('mousemove', e => {
    const cx = window.innerWidth / 2;
    const cy = window.innerHeight / 2;
    mouse.x = (e.clientX - cx) / cx;
    mouse.y = (e.clientY - cy) / cy;
  });
  window.addEventListener('resize', onResize, { passive: true });
  onResize();
}

function onResize() {
  VIEWPORT.w = window.innerWidth;
  VIEWPORT.h = window.innerHeight;
  camera.aspect = VIEWPORT.w / VIEWPORT.h;
  camera.updateProjectionMatrix();
  renderer.setSize(VIEWPORT.w, VIEWPORT.h);
  buildPageHeight();
}

function getScrollProgress() {
  const maxScroll = (SCENE_COUNT * window.innerHeight) - window.innerHeight;
  return Math.min(1, Math.max(0, (targetScroll / maxScroll)));
}

function animate() {
  requestAnimationFrame(animate);
  currentScroll += (targetScroll - currentScroll) * LERP_EASE;
  const progress = getScrollProgress();
  const totalTravel = (SCENE_COUNT - 1) * SCENE_DISTANCE;
  const desiredCamY = -progress * totalTravel;
  camera.position.y += (desiredCamY - camera.position.y) * LERP_EASE;
  camera.position.z += ((CAMERA_Z - (CAMERA_Z * 0.05)) - camera.position.z) * (LERP_EASE * 1.2);
  mouseLerp.x += (mouse.x - mouseLerp.x) * (MOUSE_INTENSITY * LERP_EASE * 6);
  mouseLerp.y += (mouse.y - mouseLerp.y) * (MOUSE_INTENSITY * LERP_EASE * 6);
  camera.rotation.x = THREE.MathUtils.degToRad(mouseLerp.y * 4);
  camera.rotation.y = THREE.MathUtils.degToRad(-mouseLerp.x * 6);

  planes.forEach(p => {
    const tx = mouseLerp.x * (0.5 + p.index * 0.6);
    const distanceToCam = Math.abs(camera.position.y - p.mesh.position.y);
    const baseScale = 1 + Math.max(0, (0.08 - distanceToCam * 0.01));
    p.mesh.position.x += (tx - p.mesh.position.x) * 0.06;
    p.mesh.scale.x += (baseScale - p.mesh.scale.x) * 0.06;
    p.mesh.scale.y += (baseScale - p.mesh.scale.y) * 0.06;
    p.mesh.position.z += ((-0.05 * p.index) - p.mesh.position.z) * 0.03;
  });

  renderer.render(scene, camera);
}

window.addEventListener('load', () => { targetScroll = window.scrollY || window.pageYOffset; });
init().catch(err => {
  console.error('WebGL init error', err);
  const msg = document.createElement('div');
  msg.className = 'no-webgl';
  msg.innerHTML = 'Error initializing WebGL. Check console.';
  document.body.appendChild(msg);
});
</script>
</body>
</html>
